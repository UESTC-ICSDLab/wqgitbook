# 运行吧, 第一个汇编程序

在上一小节中, 我们已经搭建好了一个基础的 Keil 开发环境, 在本小节中, 我们将在源文件中编写程序并进行仿真测试.

在 Keil 工程中打开源文件 "startup_CMSDK_CM0.s", 可以发现我们已经编辑好了 Cortex-M0 的初始化汇编, 对于这些代码大家可以先不用去关心, 在之后的章节中我们会对这些初始化代码进行展开讨论. 你需要做的只是在源代码的这个位置:

```armasm
;Inset a loop algorithm there;

;****************************;
```
插入以下代码:
```armasm
;Inset a loop algorithm there;
                AREA	template, CODE, READONLY
start           PROC
                MOVS    R1,     #4
Clear           MOVS    R0,     #0
Adder           ADDS    R0,     R0,     #1
                CMP     R0,     R1
                BEQ     Clear
                BNE     Adder
                ENDP
;****************************;
```
这段代码实现的功能很简单: 使 R0 在 0 到 4 间循环计数. 
<!-- -->
> #### important::不要指望我在这里讲解基本语法
> 在实验过程中, 我们认为你已经掌握了 ARM 的基本语法, 包括指令语法和伪指令语法, 虽然有些易错点我还是会强调指出, 但你们更应该养成独立查阅资料的习惯.

保存编写的文件, 然后点击 Keil 工具栏中的编译按钮, 对工程进行编译.

<center><img src="/img/lab1/02-11.png" alt="02-11" style="zoom:80%;" /></center><center style="color:#0";>编译工程</center> 

<!-- -->
> #### question::有三个编译按钮, 我应该选哪一个?
> + <img src="/img/lab1/02-12.png" alt="02-12" style="zoom:100%;" />
: 只编译当前文件, 这种编译单独文件的行为一般被称为 translate, translate 会生成当前文件的 .o 目标文件.
> + <img src="/img/lab1/02-13.png" alt="02-13" style="zoom:100%;" />
: 整个工程的增量编译, 只对修改过了的文件进行编译, 生成 .o 目标文件, 然后链接生成 .axf 可执行文件, 是大多数情况下推荐的选择.
> + <img src="/img/lab1/02-14.png" alt="02-14" style="zoom:100%;" />
: 对整个工程的全部文件进行编译, 效果与增量编译相同.

编译成功后, 点击工具栏中的<img src="/img/lab1/02-15.png" alt="02-15" style="zoom:100%;" />按钮进入程序调试模式, 由于在上一节中我们设置调试模式为软件仿真, 所以接下来的程序运行现象都是软件仿真得到的.

<center><img src="/img/lab1/02-16.png" alt="02-16" style="zoom:100%;" /></center><center style="color:#0";>调试界面</center> 

上图展示了调试界面的三个重要窗口:
+ 1: 寄存器窗口. 展示了随着程序运行的每一步, CPU中 (当然这个CPU是软件模拟出来的) 每个寄存器的值的变化.
+ 2: 反汇编窗口. 展示反汇编得到的汇编代码, 并指示当前程序运行到的位置.
+ 3: 源代码窗口. 展示程序的源代码 (汇编, c等), 并指示当前程序运行到的位置.

<!-- -->
> #### question::不容小觑的 "反汇编"
> + 程序是基于最终的机器码运行的, 在很久以前, 我们还没有这么如今这么先进的调试工具, 只能通过观察机器码的运行情况对程序进行调试, 但是机器码看着实在太难受了. 于是有了反汇编器, 它通过机器码反向生成其对应的汇编代码, 从而为我们调试程序提供了方便. 
> + 直到如今, 反汇编还在发挥着巨大的作用, 因为它的价值不仅体现在程序的调试, 比如当我们期望解读一个 .o 目标文件中的机器码时, 可以调用反汇编器将其转换成方便阅读的汇编代码.
> + 反汇编器是个 "死脑筋", 它会把所有二进制数据都进行反汇编, 不管这些数据是否是机器码, <font color='red'>所以我们会看到反汇编窗口中所有未使用的 0 数据都被反汇编成了 MOV R0, R0 指令</font>.

<!-- -->
> #### hint::程序从哪里开始运行
> 刚进入调试界面时, 通过源代码窗口可以看到程序停留在 Reset_Handler 中, 并且每次按下复位按钮<img src="/img/lab1/02-19.png" alt="02-19" style="zoom:100%;" />时, 程序都会被复位到这个地方, 这是因为刚开始 CPU 会接收到一个复位中断, ROM 中内嵌的中断向量表会告知 CPU 复位中断服务程序 (代码中的Reset_Handler) 的入口, 本实验中中断服务程序中只有一条指令, 其作用是使程序跳转到 start 地址执行, 而 start 地址正是我们添加的循环计数程序的入口.
> <center><img src="/img/lab1/02-18.png" alt="02-18" style="zoom:80%;" /></center><center style="color:#0";>复位中断服务程序</center>

这时按下<img src="/img/lab1/02-17.png" alt="02-17" style="zoom:100%;" />或者 F11 键启动单步调试, 随着程序的单步运行, 可以看到寄存器窗口中 R15(PC) 的值在不断变化, R0 的值在 0-4 之间循环计数. 这些现象表明, 你的第一个汇编程序已经成功运行起来啦!